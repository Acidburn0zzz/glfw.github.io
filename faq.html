<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>GLFW - FAQ</title><link rel="stylesheet" type="text/css" href="css/base-min.css"><link rel="stylesheet" type="text/css" href="css/grids-min.css"><link rel="stylesheet" type="text/css" href="css/style.css"><link rel="alternate" type="application/atom+xml" href="feed/index.xml"></head><body> <header class="main"><div class="wrapper"><div class="pure-g"><div class="pure-u-1-5"> <a href="index.html" id="glfw_home">GLFW</a></div><div class="pure-u-4-5"> <nav> <a href="documentation.html">Documentation</a> <a href="download.html">Download</a> <a href="media.html">Media</a> <a href="community.html">Community</a> </nav></div></div></div> </header> <section><div class="wrapper"><h2 class="no_toc" id="frequently-asked-questions">Frequently Asked Questions</h2><p>This page attempts to address some of the most commonly asked questions that we have received from GLFW users.</p><h3 class="no_toc" id="table-of-contents">Table of contents</h3><ul id="markdown-toc"><li><a href="#introduction" id="markdown-toc-introduction">Introduction</a><ul><li><a href="#what-is-glfw" id="markdown-toc-what-is-glfw">1.1 - What is GLFW?</a></li><li><a href="#what-is-glfw-not" id="markdown-toc-what-is-glfw-not">1.2 - What is GLFW not?</a></li><li><a href="#why-yet-another-opengl-library" id="markdown-toc-why-yet-another-opengl-library">1.3 - Why yet another OpenGL library?</a></li><li><a href="#what-platforms-are-supported-by-glfw" id="markdown-toc-what-platforms-are-supported-by-glfw">1.4 - What platforms are supported by GLFW?</a></li><li><a href="#what-versions-of-opengl-are-supported-by-glfw" id="markdown-toc-what-versions-of-opengl-are-supported-by-glfw">1.5 - What versions of OpenGL are supported by GLFW?</a></li></ul></li><li><a href="#general" id="markdown-toc-general">General</a><ul><li><a href="#why-use-separate-redgreenblue-bit-depths" id="markdown-toc-why-use-separate-redgreenblue-bit-depths">2.1 - Why use separate red/green/blue bit depths?</a></li><li><a href="#is-it-possible-to-change-video-modes-after-a-window-has-been-created" id="markdown-toc-is-it-possible-to-change-video-modes-after-a-window-has-been-created">2.2 - Is it possible to change video modes after a window has been created?</a></li><li><a href="#will-image-or-texture-loading-support-be-added-to-glfw" id="markdown-toc-will-image-or-texture-loading-support-be-added-to-glfw">2.3 - Will image or texture loading support be added to GLFW?</a></li><li><a href="#will-sound-support-be-added-to-glfw" id="markdown-toc-will-sound-support-be-added-to-glfw">2.4 - Will sound support be added to GLFW?</a></li><li><a href="#will-font-or-text-rendering-support-be-added-to-glfw" id="markdown-toc-will-font-or-text-rendering-support-be-added-to-glfw">2.5 - Will font or text rendering support be added to GLFW?</a></li><li><a href="#will-pop-up-menu-support-be-added-to-glfw" id="markdown-toc-will-pop-up-menu-support-be-added-to-glfw">2.6 - Will pop-up menu support be added to GLFW?</a></li><li><a href="#will-message-box-support-be-added-to-glfw" id="markdown-toc-will-message-box-support-be-added-to-glfw">2.7 - Will message box support be added to GLFW?</a></li><li><a href="#what-is-unicode" id="markdown-toc-what-is-unicode">2.8 - What is Unicode?</a></li><li><a href="#is-glfw-thread-safe" id="markdown-toc-is-glfw-thread-safe">2.9 - Is GLFW thread safe?</a></li><li><a href="#can-i-check-several-keys-at-once" id="markdown-toc-can-i-check-several-keys-at-once">2.10 - Can I check several keys at once?</a></li><li><a href="#what-timer-apis-does-glfw-use" id="markdown-toc-what-timer-apis-does-glfw-use">2.11 - What timer APIs does GLFW use?</a></li><li><a href="#what-window-system-apis-does-glfw-use" id="markdown-toc-what-window-system-apis-does-glfw-use">2.12 - What window system APIs does GLFW use?</a></li><li><a href="#why-doesnt-your-glh-have-the-functions-i-need" id="markdown-toc-why-doesnt-your-glh-have-the-functions-i-need">2.13 - Why doesn’t your gl.h have the functions I need?</a></li><li><a href="#why-do-my-objects-look-all-wrong" id="markdown-toc-why-do-my-objects-look-all-wrong">2.14 - Why do my objects look all wrong?</a></li><li><a href="#can-i-use-extension-loaders-with-glfw" id="markdown-toc-can-i-use-extension-loaders-with-glfw">2.15 - Can I use extension loaders with GLFW?</a></li><li><a href="#how-do-i-use-c-methods-as-callbacks" id="markdown-toc-how-do-i-use-c-methods-as-callbacks">2.16 - How do I use C++ methods as callbacks?</a></li></ul></li><li><a href="#windows" id="markdown-toc-windows">Windows</a><ul><li><a href="#what-compilers-are-supported-by-glfw" id="markdown-toc-what-compilers-are-supported-by-glfw">3.1 - What compilers are supported by GLFW?</a></li><li><a href="#why-do-i-get-link-errors-when-trying-to-build-my-program" id="markdown-toc-why-do-i-get-link-errors-when-trying-to-build-my-program">3.2 - Why do I get link errors when trying to build my program?</a></li><li><a href="#why-doesnt-glfwswapinterval-work" id="markdown-toc-why-doesnt-glfwswapinterval-work">3.3 - Why doesn’t glfwSwapInterval work?</a></li><li><a href="#what-libraries-should-i-link-with" id="markdown-toc-what-libraries-should-i-link-with">3.4 - What libraries should I link with?</a></li><li><a href="#why-does-my-application-freeze-when-i-move-or-resize-the-window" id="markdown-toc-why-does-my-application-freeze-when-i-move-or-resize-the-window">3.5 - Why does my application freeze when I move or resize the window?</a></li></ul></li><li><a href="#os-x" id="markdown-toc-os-x">OS X</a><ul><li><a href="#how-do-i-create-an-opengl-30-context" id="markdown-toc-how-do-i-create-an-opengl-30-context">4.1 - How do I create an OpenGL 3.0+ context?</a></li><li><a href="#what-libraries-should-i-link-with-1" id="markdown-toc-what-libraries-should-i-link-with-1">4.2 - What libraries should I link with?</a></li><li><a href="#why-is-my-output-in-the-lower-left-corner-of-the-window" id="markdown-toc-why-is-my-output-in-the-lower-left-corner-of-the-window">4.3 - Why is my output in the lower-left corner of the window?</a></li></ul></li><li><a href="#unix--x11" id="markdown-toc-unix--x11">Unix / X11</a><ul><li><a href="#what-libraries-should-i-link-with-2" id="markdown-toc-what-libraries-should-i-link-with-2">5.1 - What libraries should I link with?</a></li></ul></li></ul><hr/><h2 id="introduction">Introduction</h2><h3 id="what-is-glfw">1.1 - What is GLFW?</h3><p>GLFW is a small C library that lets you create and manage windows, OpenGL and OpenGL ES contexts and Vulkan surfaces, enumerate monitors and video modes as well as handle inputs such as keyboard, mouse, joystick, clipboard and time.</p><p>GLFW provides a thin, multi-platform abstraction layer, primarily for applications whose sole graphics output is through OpenGL, OpenGL ES or Vulkan. While GLFW is very useful when developing multi-platform OpenGL applications, single-platform developers can also benefit from avoiding having to deal with kludgy platform-specific APIs.</p><p>Libraries like GLFW are useful because OpenGL and OpenGL ES by themselves do not provide any mechanisms for creating the necessary context, managing windows, user input, timing etc. As stated in the OpenGL 3.1 Specification (chapter 2, first paragraph):</p><blockquote><p>OpenGL is concerned only with rendering into a framebuffer (and reading values stored in that framebuffer). There is no support for other peripherals sometimes associated with graphics hardware, such as mice and keyboards. Programmers must rely on other mechanisms to obtain user input.</p></blockquote><p>GLFW matches the description of <em>other mechanisms</em> quite well.</p><p>Unlike the GL APIs, Vulkan does provide its own instance and surface creation functions, but surface creation is platform-specific and the API still only covers rendering.</p><h3 id="what-is-glfw-not">1.2 - What is GLFW not?</h3><p>GLFW is <em>by design</em> not…</p><ul><li>an implementation of OpenGL, OpenGL ES or Vulkan. It wraps the various platform-specific context and surface creation API.</li><li>an OpenGL, OpenGL ES or Vulkan header. It includes the API headers already provided by your development environment.</li><li>an OpenGL, OpenGL ES or Vulkan extension loader. There are already good extension loader libraries for the GL APIs.</li><li>a user interface library. It allows you to create top-level windows with OpenGL and OpenGL ES contexts and Vulkan surfaces. No menus, no buttons.</li><li>a Windows-only library. Requests for features that cannot be portably implemented will be denied unless they are unobtrusive, like the Windows port looking for a <code class="highlighter-rouge">GLFW_ICON</code> resource at window creation.</li><li>a threading library. There are already good cross-platform threading libraries and threading has been added to both the C11 and C++11 standard libraries.</li><li>an image loading library. There are already good cross-platform image loading libraries.</li><li>capable of rendering text. There are already several libraries that render text with OpenGL and consistent cross-platform text rendering cannot depend on the platform’s text rendering facilities anyway.</li><li>capable of rendering anything at all. Rendering is up to you and/or other libraries.</li><li>integrated with <em>any</em> user interface toolkit on <em>any</em> platform. Good UI toolkits already provide OpenGL-capable widgets and having two libraries both talking to the vast global state of a window system is asking for trouble.</li><li>able to play back sound.</li><li>GLUT or SDL.</li></ul><h3 id="why-yet-another-opengl-library">1.3 - Why yet another OpenGL library?</h3><p>There are several other libraries available for aiding OpenGL development. The most common ones are <a href="http://freeglut.sourceforge.net/">freeglut</a>, an Open Source implementation of GLUT, and <a href="http://www.libsdl.org/">SDL</a>.</p><p>However, freeglut is mostly concerned with providing a stable clone of GLUT, while SDL is too large for some people and has never had OpenGL as its main focus.</p><p>We therefore believe that there is room for a lightweight, modern library for managing OpenGL contexts, windows and input.</p><h3 id="what-platforms-are-supported-by-glfw">1.4 - What platforms are supported by GLFW?</h3><p>Currently, GLFW supports Windows (XP and later), OS X (10.7 Lion and later) and Unix-like operating systems with the X Window System, such as Linux, FreeBSD and Cygwin. Support for Wayland and Mir is available but not yet feature complete.</p><p>GLFW is designed to be as portable as possible, and the code has been written with portability in mind.</p><h3 id="what-versions-of-opengl-are-supported-by-glfw">1.5 - What versions of OpenGL are supported by GLFW?</h3><p><strong>TL;DR</strong> All versions supported by your operating system, driver and GPU.</p><p>This question likely stems from the original version of the <a href="http://www.opengl.org/registry/specs/ARB/wgl_create_context.txt"><code class="highlighter-rouge">WGL_ARB_create_context</code></a> and <a href="http://www.opengl.org/registry/specs/ARB/glx_create_context.txt"><code class="highlighter-rouge">GLX_ARB_create_context</code></a> extensions, which stated that the old context creation mechanism would be limited to OpenGL version 2.1. However, this is no longer the case and the specifications have been updated accordingly.</p><p>GLFW 2.6 and earlier use only the older context creation mechanism, which on Windows and X11 may return contexts of any version, however new, provided they implement the <a href="http://www.opengl.org/registry/specs/ARB/compatibility.txt"><code class="highlighter-rouge">ARB_compatibility</code></a> extension. Most modern drivers do this.</p><p>Explicit creation of OpenGL contexts of version 3.0 and above on Windows and X11, including profiles and flags, is supported by GLFW 2.7 and later.</p><p>However, OS X did not support OpenGL 3.0 or later at the time that GLFW 2.7 was released, and the support that Apple has since added only includes forward-compatible OpenGL 3.2 core profile contexts. Additionally, creating such contexts requires new code, so older versions of GLFW cannot create OpenGL 3.0 contexts on OS X.</p><p>The first version to support creation of OpenGL 3.2 contexts on OS X Lion and later was GLFW 2.7.2.</p><hr/><h2 id="general">General</h2><h3 id="why-use-separate-redgreenblue-bit-depths">2.1 - Why use separate red/green/blue bit depths?</h3><p>Because that is how most platforms describe OpenGL-capable pixel formats and how OpenGL describes its framebuffers. It makes GLFW more consistent with the APIs it interacts with, and more future-proof.</p><p>This doesn’t, of course, prevent you from presenting the familiar, single value color depths to the user.</p><h3 id="is-it-possible-to-change-video-modes-after-a-window-has-been-created">2.2 - Is it possible to change video modes after a window has been created?</h3><p>You can change the resolution of a full screen window with <code class="highlighter-rouge">glfwSetWindowSize</code>, but the pixel format, i.e. the framebuffer bit depths will remain the same. Changing the pixel format requires the context to be recreated.</p><h3 id="will-image-or-texture-loading-support-be-added-to-glfw">2.3 - Will image or texture loading support be added to GLFW?</h3><p>No.</p><h3 id="will-sound-support-be-added-to-glfw">2.4 - Will sound support be added to GLFW?</h3><p>No.</p><p>However, if you are looking for an OpenGL-like API for sound, have a look at OpenAL.</p><h3 id="will-font-or-text-rendering-support-be-added-to-glfw">2.5 - Will font or text rendering support be added to GLFW?</h3><p>No.</p><p>There are already several competent font rendering toolkits available for OpenGL, none of which require integration with a context or window management library.</p><h3 id="will-pop-up-menu-support-be-added-to-glfw">2.6 - Will pop-up menu support be added to GLFW?</h3><p>No.</p><h3 id="will-message-box-support-be-added-to-glfw">2.7 - Will message box support be added to GLFW?</h3><p>Not right now.</p><p>The main issue keeping this from being added is the lack of a standard, Unicode-enabled UI toolkit on Unix-like systems such as Linux and FreeBSD. Depending on, say, Gtk+, would therefore introduce a dependency on a huge amount of code not necessarily present on the user’s machine.</p><p>As there is no reason why message box code has to be integrated into GLFW, it is better to leave that functionality to a separate library.</p><h3 id="what-is-unicode">2.8 - What is Unicode?</h3><p><strong>Unicode</strong> (sometimes referred to as ISO 10646), is a character coding standard that encodes virtually every character from every written language in the world into a common character set. It is gaining acceptance worldwide, and today most platforms, computer languages and APIs have some sort of support for Unicode (GLFW now being one of them).</p><p><em>Visit <a href="http://www.unicode.org">The Unicode Consortium</a> for more information about Unicode.</em></p><p><em>See also <a href="http://en.wikipedia.org/wiki/Unicode">Wikipedia on Unicode</a>.</em></p><h3 id="is-glfw-thread-safe">2.9 - Is GLFW thread safe?</h3><p>Some parts are, specifically those needed to allow rendering and Vulkan object creation from secondary threads. See <a href="http://www.glfw.org/docs/latest/intro.html#thread_safety">Thread Safety</a> in the documentation for details.</p><h3 id="can-i-check-several-keys-at-once">2.10 - Can I check several keys at once?</h3><p>Yes, you can.</p><p>The function <code class="highlighter-rouge">glfwGetKey</code> lets you check the state of any keyboard key (including special keys). You can even call the function from within a callback function, which makes it possible to check for things like Ctrl+F3 key events (when you get a <code class="highlighter-rouge">GLFW_KEY_F3</code> key press event, check the state of the left or right CTRL key with <code class="highlighter-rouge">glfwGetKey(window, GLFW_KEY_LEFT_CONTROL)</code> or <code class="highlighter-rouge">glfwGetKey(window, GLFW_KEY_RIGHT_CONTROL)</code>, or both).</p><h3 id="what-timer-apis-does-glfw-use">2.11 - What timer APIs does GLFW use?</h3><p>On Windows, the <code class="highlighter-rouge">QueryPerformanceCounter</code> API is used if available, with <code class="highlighter-rouge">timeGetTime</code> as a fallback.</p><p>On OS X, the Mach <code class="highlighter-rouge">mach_absolute_time</code> time source is used.</p><p>On Unix-like operating systems using the X11, Wayland and Mir ports, the POSIX <code class="highlighter-rouge">CLOCK_MONOTONIC</code> time source is used if available, with <code class="highlighter-rouge">gettimeofday</code> as a fallback.</p><h3 id="what-window-system-apis-does-glfw-use">2.12 - What window system APIs does GLFW use?</h3><p>On Windows, plain Win32 is used for window and input management, and WGL or EGL to create OpenGL and OpenGL ES contexts.</p><p>On OS X, Cocoa is used for window and input management, and NSOpenGL to create OpenGL contexts.</p><p>On Unix-like systems using the X Window System, the Xlib API is used for window and input management, and GLX or EGL to create OpenGL and OpenGL ES contexts.</p><p>On Linux systems using Wayland, the Wayland API is used for window and input management, and EGL to create OpenGL and OpenGL ES contexts.</p><p>On Linux systems using Mir, the Mir API is used for window and input management, and EGL to create OpenGL and OpenGL ES contexts.</p><h3 id="why-doesnt-your-glh-have-the-functions-i-need">2.13 - Why doesn’t your gl.h have the functions I need?</h3><p>GLFW does not provide any version of either <code class="highlighter-rouge">gl.h</code> or <code class="highlighter-rouge">glu.h</code>. The <code class="highlighter-rouge">glfw3.h</code> header file includes the versions already present in your development environment.</p><p>However, if you are using Windows, you cannot get anything newer than OpenGL 1.2 without using extensions. As the extension management in GLFW is very rudimentary, we recommend that you use a dedicated extension loading library such as <a href="https://github.com/Dav1dde/glad">glad</a>.</p><h3 id="why-do-my-objects-look-all-wrong">2.14 - Why do my objects look all wrong?</h3><p>GLFW does not wrap OpenGL. No GLFW code is involved when you make an OpenGL call. Think instead of GLFW as connecting your code to OpenGL and then getting out of the way. That connection is the OpenGL context you create and make current with GLFW. If you get incorrect rendering results, it is therefore most likely due to errors in your code, the OpenGL implementation or both.</p><p>The OpenGL.org wiki has an extensive article on <a href="https://www.opengl.org/wiki/Common_Mistakes">common mistakes</a> that may be able to help you locate the problem.</p><h3 id="can-i-use-extension-loaders-with-glfw">2.15 - Can I use extension loaders with GLFW?</h3><p>Yes, as long as you prevent the GLFW header from including the platform client API header (for example <code class="highlighter-rouge">gl.h</code> for OpenGL). There are two ways to do this. Either include the extension loader header before including the GLFW header:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;glad/glad.h&gt;
#include &lt;GLFW/glfw3.h&gt;</span></code></pre></figure><p>The extension loader header will disable and replace the standard OpenGL header that the GLFW header includes. You can also disable the standard OpenGL header yourself by defining <code class="highlighter-rouge">GLFW_INCLUDE_NONE</code> before including the GLFW header. This will let you include the GLFW and extension loader headers in any order:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define GLFW_INCLUDE_NONE
#include &lt;GLFW/glfw3.h&gt;
#include &lt;glad/glad.h&gt;</span></code></pre></figure><h3 id="how-do-i-use-c-methods-as-callbacks">2.16 - How do I use C++ methods as callbacks?</h3><p>You cannot use regular methods as callbacks, as GLFW is a C library and doesn’t know about objects and <code class="highlighter-rouge">this</code> pointers. If you wish to receive callbacks to a C++ object, use static methods or regular functions as callbacks, store the pointer to the object you wish to call as the user pointer for the window and use it to call methods on your object.</p><hr/><h2 id="windows">Windows</h2><h3 id="what-compilers-are-supported-by-glfw">3.1 - What compilers are supported by GLFW?</h3><p>Currently, GLFW releases are tested with MinGW, MinGW-w64 and Visual C++ 2010, 2012, 2013 and 2015, but it should work with any compiler that supports C99 (C89 on Windows). Very old development environments may require updated system headers.</p><p>The Windows binary distribution of GLFW contains pre-compiled libraries for both MinGW and the most recent versions of Visual C++.</p><h3 id="why-do-i-get-link-errors-when-trying-to-build-my-program">3.2 - Why do I get link errors when trying to build my program?</h3><p>See the <a href="http://www.glfw.org/docs/latest/build.html">Building programs that use GLFW</a> guide for details on how to compile and link programs on various platforms.</p><h3 id="why-doesnt-glfwswapinterval-work">3.3 - Why doesn’t glfwSwapInterval work?</h3><p>Modern graphics drivers have settings that allow users to override an application’s request for (among other things) swap interval. If such a setting is enabled, <code class="highlighter-rouge">glfwSwapInterval</code> will have no effect.</p><h3 id="what-libraries-should-i-link-with">3.4 - What libraries should I link with?</h3><p>See the <a href="http://www.glfw.org/docs/latest/build.html">Building programs that use GLFW</a> guide for details.</p><h3 id="why-does-my-application-freeze-when-i-move-or-resize-the-window">3.5 - Why does my application freeze when I move or resize the window?</h3><p>The Windows event loop is blocked by certain actions like dragging or resizing a window, or opening the window menu. This is part of the design of Windows and cannot be changed by GLFW. If you wish to keep rendering during such actions, you should render from a secondary thread.</p><hr/><h2 id="os-x">OS X</h2><h3 id="how-do-i-create-an-opengl-30-context">4.1 - How do I create an OpenGL 3.0+ context?</h3><p>The only OpenGL 3.x and 4.x contexts currently supported by OS X are forward-compatible, core profile contexts. The supported versions are 3.2 on 10.7 Lion and 3.3 and 4.1 on 10.9 Mavericks. In all cases, your GPU needs to support the specified OpenGL version for context creation to succeed.</p><p>To create either an OpenGL 3.2 or later context, you should set the following hints:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MAJOR</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_CONTEXT_VERSION_MINOR</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_OPENGL_FORWARD_COMPAT</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">);</span>
<span class="n">glfwWindowHint</span><span class="p">(</span><span class="n">GLFW_OPENGL_PROFILE</span><span class="p">,</span> <span class="n">GLFW_OPENGL_CORE_PROFILE</span><span class="p">);</span></code></pre></figure><p>This will give you a context for the highest version of OpenGL greater than or equal to 3.2 that is supported by your OS and GPU. This works because no features were deprecated between OpenGL 3.2 and 4.1, making forward-compatible OpenGL 4.1 backards-compatible with 3.2. If the requested version is not supported, window creation will fail.</p><p>If your code requires OpenGL 3.3 or 4.1, you can specify those versions instead, as well as any valid OpenGL version in between.</p><h3 id="what-libraries-should-i-link-with-1">4.2 - What libraries should I link with?</h3><p>See the <a href="http://www.glfw.org/docs/latest/build.html">Building programs that use GLFW</a> guide for details.</p><h3 id="why-is-my-output-in-the-lower-left-corner-of-the-window">4.3 - Why is my output in the lower-left corner of the window?</h3><p>You are passing the window size, which is in screen coordinates, to <code class="highlighter-rouge">glViewport</code>, which works with pixels. On OS X with a Retina display, and possibly on other platforms in the future, screen coordinates and pixels do not map 1:1. Use the framebuffer size, which is in pixels, instead of the window size. See the <a href="http://www.glfw.org/docs/latest/window.html">Window handling guide</a> for details.</p><hr/><h2 id="unix--x11">Unix / X11</h2><h3 id="what-libraries-should-i-link-with-2">5.1 - What libraries should I link with?</h3><p>See the <a href="http://www.glfw.org/docs/latest/build.html">Building programs that use GLFW</a> guide for details.</p></div> </section> <footer><div class="wrapper"><div class="pure-g-r"><div class="pure-u-1-4"><h4>Community</h4><ul><li><a href="community.html">IRC Channel</a></li><li><a href="http://discourse.glfw.org/">Support Forum</a></li></ul></div><div class="pure-u-1-4"><h4>Development</h4><ul><li><a href="/docs/latest/">Documentation</a></li><li><a href="download.html#bindings">Language Bindings</a></li><li><a href="https://github.com/glfw">GitHub Repositories</a></li></ul></div><div class="pure-u-1-4"><h4>News</h4><ul><li><a href="feed/index.xml">Atom Feed</a></li><li><a href="news.html">News Archive</a></li><li><a href="changelog.html">Version History</a></li></ul></div><div class="pure-u-1-4"><h4>About</h4><ul><li><a href="faq.html">FAQ</a></li><li><a href="license.html">License</a></li></ul></div></div></div> </footer></body></html>